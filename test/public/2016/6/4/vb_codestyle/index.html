<body>
<h2>Code Architecture of a VisualBasic CLI program</h2>

<p>There is a VisualBasic application helper module that define in the namespace:
<a href="https://github.com/xieguigang/VisualBasic_AppFramework/blob/master/Microsoft.VisualBasic.Architecture.Framework/Extensions/App.vb">Microsoft.VisualBasic.App</a></p>

<p><strong>A special function named <em>main</em> is the starting point of execution for all VisualBasic programs</strong>. A VisualBasic CLI application should define the <strong>Main</strong> entry point in a Module which is named <em>Program</em> and running from a Integer Function Main. By using the name of Program for the entry point module, this will makes more easily recognize of your program's entry point.</p>

<p>```vbnet
Module Program</p>

<pre><code>''' &lt;summary&gt;
''' This is the main entry point of your VisualBasic application.
''' &lt;/summary&gt;
''' &lt;returns&gt;&lt;/returns&gt;
Public Function Main() As Integer
    Return GetType(CLI).RunCLI(App.CommandLine)
End Function
</code></pre>

<p>End Module
```</p>

<p>By using a <strong>Integer</strong> <em>Function</em> instead of <em>Sub</em> in VisualBasic, this makes your code style is more standard compare with the main function from C++.</p>

<p><code>c
    int main(int argc, char *argv[]) {
        // blablabla...
    }
</code></p>

<p>Where, the type <strong>CLI</strong> is the CLI interface which it is a module that contains all of the CLI command of your application. And the extension function <strong>RunCLI</strong> is a CLI extension method from the VisualBasic App helper: <a href="https://github.com/xieguigang/VisualBasic_AppFramework/blob/master/Microsoft.VisualBasic.Architecture.Framework/Extensions/App.vb">Microsoft.VisualBasic.App</a>. The property value of <strong>App.CommandLine</strong> is the commandline argument of current application that user used for start this application and calling for some <em>CLI</em> command which is exposed in <strong>CLI</strong> module.</p>

<!--more-->

<h3>How to define the CLI module?</h3>

<p>A <strong>Module</strong> is a static <em>Class</em> type in the VisualBasic, and it usually used for <em>the API exportation and common method definition for a set of similarity or functional correlated utility functions</em>.</p>

<p>And then so that the CLI module in the VisualBasic can be explained as: <strong>A module for exposed the CLI interface API to your user.</strong></p>

<p>Here is a example:</p>

<p>```vbnet
Partial Module CLI</p>

<pre><code>&lt;ExportAPI("/Print", Usage:="/Print /in &lt;inDIR&gt; [/ext &lt;ext&gt; /out &lt;out.Csv&gt;]")&gt;
Public Function Print(args As CommandLine.CommandLine) As Integer
    Dim ext As String = args.GetValue("/ext", "*.*")
    Dim inDIR As String = args - "/in"
    Dim out As String = args.GetValue("/out", inDIR.TrimDIR &amp; ".contents.Csv")
    Dim files As IEnumerable(Of String) =
        ls - l - r - wildcards(ext) &lt;= inDIR
    Dim content As NamedValue(Of String)() =
        LinqAPI.Exec(Of NamedValue(Of String)) &lt;= From file As String
                                                  In files
                                                  Let name As String = file.BaseName
                                                  Let genome As String = file.ParentDirName
                                                  Select New NamedValue(Of String)(genome, name)
    Return content.SaveTo(out).CLICode
End Function
</code></pre>

<p>End Module
```</p>

<p>This example code can be found at: <a href="https://github.com/SMRUCC/ncbi-localblast/tree/master/Tools/CLI">github</a></p>

<h3>How to expose the CLI interface API in your application?</h3>

<p>A wrapper for parsing the commandline from your user is already been defined in namespace: <a href="https://github.com/xieguigang/VisualBasic_AppFramework/tree/master/Microsoft.VisualBasic.Architecture.Framework/CommandLine"><strong>Microsoft.VisualBasic.CommandLine</strong></a></p>

<p>And the <strong>CLI</strong> interface should define as in the format of this example:</p>

<p>```vbnet
Imports Microsoft.VisualBasic.CommandLine
Imports Microsoft.VisualBasic.CommandLine.Reflection</p>

<p><ExportAPI("/Print", Usage:="/Print /in <inDIR> [/ext <ext> /out <out.Csv>]")>
Public Function CLI_API(args As CommandLine) As Integer
```</p>

<h3>Using the VisualBasic CommandLine Parser</h3>

<p>For learn how to using the CommandLine Parser, we first lean the syntax of the VisualBasic commandline arguments.
A typical commandline arguments in VisualBasic is consist of two parts:
1. <em>Command Name</em>
2. <em>Arguments</em></p>

<p>Here is a simple example:</p>

<pre><code>App.exe /API1 /test /msg "Hello World!!!" /test2-enable /test3-enable
</code></pre>

<p>Where in this CLI, token <strong>App.exe</strong> is the executable file name of your application; And <strong>/API1</strong> token, is the <strong>Command Name</strong>; And then the last tokens are the parameter arguments, using the commandline in VisualBasic just like function programming in VisualBasic:</p>

<p><code>vbnet
Module App
    Public Function API1(test As Boolean, 
                 msg As String, 
                 test2Enable As Boolean, 
                 test3Enable As Boolean) As Integer
End Module
</code></p>

<p>You call your CLI command in the console terminal is just like call a function in the VisualBasic Code:</p>

<p><code>vbnet
    Dim code As Integer = App.API1(True, "Hello World!!!", True, True)
</code></p>

<p><strong><em>NOTE:</em> There is no order of the VisualBasic CLI arguments</strong>, so that all of these CLI examples are equals to each other:</p>

<pre><code>App.exe /API1 /msg "Hello World!!!" /test2-enable /test3-enable /test
App.exe /API1 /msg "Hello World!!!" /test /test2-enable /test3-enable
App.exe /API1 /test /test2-enable /test3-enable /msg "Hello World!!!"
App.exe /API1 /test2-enable /test /test3-enable /msg "Hello World!!!"
</code></pre>

<p>Simple Example of VisualBasic CLI application(Example source code at <a href="https://github.com/xieguigang/VisualBasic_AppFramework/tree/master/Example/CLI_Example">here</a>):</p>

<p>```vbnet
Imports Microsoft.VisualBasic.CommandLine
Imports Microsoft.VisualBasic.CommandLine.Reflection</p>

<p>Module Program</p>

<pre><code>Public Function Main() As Integer
    Return GetType(CLI).RunCLI(App.CommandLine)
End Function
</code></pre>

<p>End Module</p>

<p>Module CLI</p>

<pre><code>&lt;ExportAPI("/API1",
     Info:="Puts the brief description of this API command at here.",
     Usage:="/API1 /msg ""Puts the CLI usage syntax at here""",
     Example:="/API1 /msg ""Hello world!!!""")&gt;
Public Function API1(args As CommandLine) As Integer
    Call Console.WriteLine(args("/msg"))
    Return 0
End Function
</code></pre>

<p>End Module
```</p>

<p>Here are some mostly used function in VisualBasic CLI parser
Example CLI is:</p>

<pre><code>App.exe /Test-Example /b /n 52 /xml "~/test.Xml" /num_threads 96 /path "~/tmp/test.log"
</code></pre>

<p>|Function|Usage|Example|
|--------|-----|-------|
|CommandLine.GetBoolean(String) As Boolean|Get a boolean flag argument from the CLI|Dim b As Boolean = args.GetBoolean("/b")|
|CommandLine.GetInt32(String) As Integer|Get a parameter value as Integer|Dim n As Integer = args.GetInt32("/n")|
|CommandLine.GetObject(Of T)(String, System.Func(Of String, T)) As T|Get a parameter string value and then apply a string parser on it for load an .NET object|Dim x As T = args.GetObject(of T)("/xml", AddressOf LoadXml)|
|CommandLine.GetValue(Of T)(String, T, System.Func(Of String, T)) As T|Get a parameter value, if the parameter is not exist, then default value will be returns, this method is usually used on optional value|Dim n As Long = args.GetValue("/num_threads", 100L)|
|CommandLine.Item(String) As String|Default readonly property for read string value of a specific parameter|Dim path As String = args("/file")|</p>

<hr />

<h2>List(Of T) operation in VisualBasic</h2>

<p>For enable this language syntax feature and using the list feature in this section, you should imports the namespace <strong>Microsoft.VisualBasic</strong> at first</p>

<p><code>vbnet
    Dim source As IEnumerable(Of &lt;Type&gt;)
    Dim list As New List(of &lt;Type&gt;)(source)
</code></p>

<p>For Add a new instance</p>

<p><code>vbnet
    list += New &lt;Type&gt; With {
        .Property1 = value1,
        .Property2 = value2
    }
</code></p>

<p>For Add a sequence of new elements
<code>vbnet
    list += From x As T
            In source
            Where True = &lt;test&gt;
            Select New &lt;Type&gt; With {
                .Property1 = &lt;expression&gt;,
                .Property2 = &lt;expression&gt;
            }
</code></p>

<p>if want to removes a specific element in the list
<code>vbnet
    list -= x
</code>
Or batch removes elements:
<code>vbnet
    list -= From x As T
            In source
            Where True = &lt;test&gt;
            Select x
</code></p>

<p>Here is some example of the list <strong>+</strong> operator
<code>vbnet
    ' This add operation makes the code more easily to read and understand:
    ' This function returns a list of RfamHit element and it also merge a
    ' list of uncertainly elements into the result list at the same time
    Public Function GetDataFrame() As RfamHit() Implements IRfamHits.GetDataFrame
        Return hits.ToList(Function(x) New RfamHit(x, Me)) + From x As Hit
                                                             In Uncertain
                                                             Select New RfamHit(x, Me)
    End Function
</code>
And using the <strong>+</strong> operator for add a new object into the list, this syntax can makes the code more readable instead of the poorly readable code from by using method <strong>List(of T).Add</strong>:
```vbnet
    genomes += New GenomeBrief With {
        .Name = title,
        .Size = last.Size,
        .Y = h1
    }</p>

<pre><code>' Using the + operator to instead of this poorly readable function code
genomes.Add(New GenomeBrief With {
        .Name = title,
        .Size = last.Size,
        .Y = h1
    })
</code></pre>

<p>```</p>

<h2>VisualBasic identifer names</h2>

<h4>1. Directory type</h4>

<p>If possible, then all of the directory path variable can be <strong>UPCASE</strong>, such as:
<code>vbnet
    Dim DIR As String = "/home/xieguigang/Downloads"
    Dim EXPORT As String = "/usr/lib/GCModeller/"
</code></p>

<h4>2. Module variable</h4>

<ul>
<li>All of the module variable should in format like <strong><em>lowerUpper</strong> if the variable is _private</em></li>
<li>But if the variable is <em>Public</em> or <em>Friend</em> visible, then it should in format like <strong>UpperUpper</strong></li>
</ul>

<p>Here is some example:
```vbnet
    ' Private
    Dim _fileName As String
    Dim _inDIR As Directory</p>

<pre><code>' Public
Public ReadOnly Property FileName As String
Public ReadOnly Property InDIR As Directory
</code></pre>

<p>```</p>

<h4>3. Local varaible and function parameter</h4>

<p>If possible, all of the local varaible within a function or sub program and the parameters of a function, should be in format <strong>lowerUpper</strong></p>

<h4>4. Function And Type name</h4>

<p>For <strong><em>Public</em></strong> member function, the function name is recommended in formats <strong>UpperUpper</strong>, but if the function is <strong><em>Private, Friend, or Protected</em></strong> visible, then your function is recommended start with two underlines, likes <strong>__lowerUpper</strong>. The definition of the <em>Class, Structure</em> names is in the same rule as function name.</p>

<p>Here is some function name examples(Example picked from <a href="https://github.com/SMRUCC/GCModeller.Core/Bio.Assembly/GenomicsContext/TFDensity.vb">here</a>):
<code>vbnet
    ' Private
    Private Function __worker(Of T As I_GeneBrief)(genome As IGenomicsContextProvider(Of T),
                                                getTF As Func(Of Strands, T()),
                                                getRelated As Func(Of T, T(), Integer, T()),
                                                numTotal As Integer,
                                                ranges As Integer) As Density()
    ' Public
    Public Function DensityCis(Of T As I_GeneBrief)(
                                genome As IGenomicsContextProvider(Of T),
                                TF As IEnumerable(Of String),
                                Optional ranges As Integer = 10000) As Density()
</code></p>

<p><img src="https://raw.githubusercontent.com/xieguigang/VisualBasic_AppFramework/master/vb_codestyle/FunctionNames.png" alt="" /></p>

<ul>
<li>Interface type name should start with a upcase character <strong>I</strong>, like <em>IEnumerable</em>, <em>IList</em>, etc</li>
<li>Enum type name should end with a lower case character <strong>s</strong>, like <em>MethodTypes</em>, <em>FormatStyles</em></li>
</ul>

<p>At last, for improves of the code readable, try <em><strong>Make your identifier name short enough as possible</strong></em></p>

<p><img src="https://raw.githubusercontent.com/xieguigang/VisualBasic_AppFramework/master/vb_codestyle/codeStandard.png" alt="Code standard overview example" /></p>

<h2>String manipulate</h2>

<h6>1. String.Format</h6>

<p>For formatted a string output, then recommended used <strong>String.Format</strong> function or string interpolate syntax in VisualBasic language.
And by using the <strong>String.Format</strong> function, then format control string is recommended puts in a constant variable instead of directly used in the format function:</p>

<p><code>vbnet
    Const OutMsg As String = "Hello world, {0}, Right?"
    ' blablabla.......
    Dim msg As String = String.Format(OutMsg, name)
</code></p>

<h6>2. String contacts</h6>

<p>For contacts a large amount of string tokens, the <strong>StringBuilder</strong> is recommended used for this job, <strong>not recommend directly using <em>&amp; operator</em> to contacts a large string collection due to the reason of performance issue</strong>.
```vbnet
    ' Convert the input string to a byte array and compute the hash.
    Dim data As Byte() = md5Hash.ComputeHash(input)</p>

<pre><code>' Create a new Stringbuilder to collect the bytes
' and create a string.
Dim sBuilder As New StringBuilder()

' Loop through each byte of the hashed data
' and format each one as a hexadecimal string.
For i As Integer = 0 To data.Length - 1
    sBuilder.Append(data(i).ToString("x2"))
Next i

Return sBuilder.ToString() ' Return the hexadecimal string.
</code></pre>

<p>```</p>

<p>If you just want to contact the string, then a shared method <strong>String.Join</strong> is recommended used.
If the string tokens will be join by a specific delimiter, then using <strong>String.Join</strong> instead of <strong>StringBuilder.Append</strong></p>

<p>```vbnet
    Dim tokens As String()
    Dim sb As New StringBuilder</p>

<pre><code>For Each s As String In tokens
    Call sb.Append(s &amp; " ")
Next
Call sb.Remove(sb.Length -1)
</code></pre>

<p>```</p>

<p>Or just use <strong>String.Join</strong>, this method is more clean and readable than <strong>StringBuilder.Append</strong>:</p>

<p><code>vbnet
    Dim tokens As String()
    Dim out As String = String.Join(" ", tokens)
</code></p>

<h6>3. String interpolate</h6>

<p>The string interpolate syntax in VisualBasic language is recommended used for <strong>build <em>SQL</em> statement and <em>CLI</em> arguments as this syntax is very easily for understand and code readable</strong>:</p>

<p><code>vbnet
    Dim SQL As String = $"SELECT * FROM table WHERE id='{id}' AND ppi&gt;{ppi}"
    Dim CLI As String = $"/start /port {port} /home {PathMapper.UserHOME}"
</code></p>

<p>So, using this syntax feature makes your code very easy for reading and understand the code meaning, right?</p>

<h4>Linq Expression</h4>

<p>All of the Linq Expression is recommended execute using <a href="https://github.com/xieguigang/VisualBasic_AppFramework/blob/master/Microsoft.VisualBasic.Architecture.Framework/Language/Linq.vb"><strong>LinqAPI</strong></a> if the output type of the expression is a known type:</p>

<p><img src="https://raw.githubusercontent.com/xieguigang/VisualBasic_AppFramework/master/vb_codestyle/LinqStyle.png" alt="" /></p>

<h4>Instantiation</h4>

<p>For define a new object, a short format is recommended:
<code>vbnet
Dim x As New &lt;Type&gt;
</code></p>

<p>If the type you want to create object instance can be initialize from its property, then the With keyword is recommended to used:</p>

<p><code>vbnet
Dim MyvaCog As MyvaCOG = 
    LinqAPI.Exec(Of MyvaCOG) &lt;= From gene As GeneDumpInfo
                                In GenomeBrief
                                Select New MyvaCOG With {
                                    .COG = gene.COG,
                                    .QueryName = gene.LocusID,
                                    .QueryLength = gene.Length
                                }
</code></p>

<h2>Appendix</h2>

<p>Here are tables of names that i used in my programming, and continues updated....</p>

<h4>Some common used name for common types</h4>

<table class="table table-bordered table-striped table-condensed">
<thead>
<tr><td>System.Type</td><td>Recommend Name</td><td>Example</td></tr>
</thead>
    <tbody>
        <tr>
        <td>System.Text.StringBuilder</td>
        <td>sb</td>
        <td>
```vbnet
Dim sb As New StringBuilder
```
</td>
        </tr>
        <tr>
        <td>System.String</td>
        <td>s, str, name, sId, id, x</td>
        <td>
```vbnet        
Dim s As String
Dim str As String
Dim name As String
Dim sId As String
Dim id As String
Dim x As String
```
    </td>
    </tr>
    <tr><td>System.Integer, System.Long</td>
        <td>i, j, n, x</td>
        <td>
```vbnet
Dim i As Integer
Dim j As Integer
Dim n As Integer
Dim x As Integer
```
</tr>
    <tr><td>System.Object</td>
        <td>x, o, obj, value</td>
        <td>
```vbnet
Dim x As Object
Dim o As Object
Dim obj As Object
Dim value As Object
```
</td>
    </tr>
        </tbody>
</table>

<h4>Name for some meaning</h4>

<table>
   <tr><td>Meaning</td><td>Recommend Name</td><td>Example</td></tr>
   <tr><td>Commandline arguments</td>
       <td>args, CLI</td>
       <td>
```vbnet
Dim args As CommandLine
Dim CLI As String
Dim args As String()
```
</td></tr>
    <tr><td>SQL query</td>
        <td>SQL, sql, query</td>
        <td>
```vbnet
Dim SQL As String = "SELECT * FROM table LIMIT 1;"
```
</td>
    </tr>
    <tr><td>Iterator</td>
        <td>i, j, k, l</td>
        <td>
```vbnet
For i As Integer = 0 to [stop]
    For j As Integer = i to [stop]
        For k As Integer = j to [stop]
        Next
    Next
Next

Dim l As Integer = 100

Do while l = 100
    ' blablabla...
Loop
```
</td>
    </tr>
    <tr><td>Linq query expression</td><td>LQuery</td><td>
```vbnet
Dim LQuery = From path As String
             In ls -l -r -wildcards("*.Xml") <= DIR
             Where InStr(path.BaseName, "xcb") = 1
             Select path.LoadXml(Of KEGG.DBGET.Module)
```
</td>
</tr>
    <tr>
        <td>Query Result/Function Returns</td><td>result, rtvl</td><td>
```vbnet
Dim result As [Module] = 
    LinqAPI.Exec(Of [Module]) <= 
          From path As String
          In ls -l -r -wildcards("*.Xml") <= DIR
          Where InStr(path.BaseName, "xcb") = 1
          Select path.LoadXml(Of KEGG.DBGET.Module)

Return result
```
</td>
</tr>
    <tr><td>Directory</td><td>DIR, out, inDIR</td><td>
```vbnet
Dim files As IEnumerable(Of String) = 
    ls -l -r -wildcards("*.Xml") <= DIR
```
</td>
</tr>
    <tr><td>json</td><td>json, JSON</td><td>
```vbnet
Dim JSON As String = (ls -l -r -wildcards("*.json") <= DIR).GetJson
```
</td>
</tr>
    <tr><td>data frame</td><td>df, ds, data</td><td>
```vbnet
Dim df As DataFrame = DataFrame.CreateObject(path)
```
</td>
</tr>
    <tr><td>Network objects</td><td>net, network, node, nodes, edge, edges</td><td>
```vbnet
Dim net As Network = Network.Load(DIR)

net += New Node With {
    .Identifier = "Linq"
}
net += New Edge With {
    .FromNode = "Linq",
    .ToNode = "SQL"
}
Return net >> Open("./test.net/")
```
</td>
</tr>
</table>
</body>
